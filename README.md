# Дедов Иван Андреевич БПИ-234
# SET-9 Задание А1 "Анализ строковых алгоритмов"


1. Структура проекта
    - Папка `A1m` и файл `main.cpp` - реализация алгоритма `STRING MERGE SORT`. Были использованы материалы по LCP из недели 14. ID посылки: 321262150
    - Папка `A1q` и файл `main.cpp` - реализация алгоритма `STRING QUICK SORT`. ID посылки: 321245887
    - Папка `A1r` и файл `main.cpp`- реализация алгоритма `MSD RADIX SORT`. ID посылки: 320674445
    - Папка `A1rq` и файл `main.cpp` - реализация алгоритма `MSD RADIX + QUICK SORT`. ID посылки: 320675553
    - Папка `StandardMergeSort` и файл `main.cpp` - стандартная реализация `MERGE SORT` и проверка её на работоспособность.
    - Папка `StandardQuickSort` и файл `main.cpp` - стандартная реализация `QUICK SORT` и проверка её на работоспособность.
    - Папка `Analysing_Process` и файл `sorting_algorithms_analysis.cpp`.
    - Папка `Python_Analyzing_Results` и файл `main.py` - скрипт Python для визуализации результатов, расположенных в папке `sorts_results.csv`.  В ней располагается 8 фотографий, описывающих количество итераций и время на сортировку для различных видов массивов.


2. Тестирование 
    - Класс `StringGenerator`, который создает наборы строк с заданными характеристиками. В качестве алфавита используются 74 символа: заглавные и строчные латинские буквы, цифры и специальные символы.
    - Класс `StringSortTester` представляет собой инфраструктуру для тестирования различных алгоритмов сортировки. Он предоставляет методы для измерения времени выполнения и подсчета посимвольных сравнений.


    При выполнении этого кода сохраняется файл `sort_results.csv` в папку с исполняемым файлом. Он используется в Python части.

    - Анализ результатов тестирования представлен на графиках, сроящихся при выполнении файла `main.py` которые показывают зависимость времени выполнения и количества сравнений от размера массива для каждого типа данных.


Результаты тестироания.


Количество сравнений:
1. `comparisons_almost.png` - изображение соответствует количеству посимвольных сравнений у почти отсортированных массивов. Больше всего сравнений получилось у обычного `quick`, тогда как у обоих реализаций `merge` они совпадают. 
2. `comparisons_prefix.png`- изображение соответствует количеству посимвольных сравнений у массивов с совпадающими префиксами. Тут в лидерах `quick_sort`, а также обе сортировки `merge`.
3. `comparisons_random.png`- изображение соответствует количеству посимвольных сравнений у рандомных массивов строк. Меньше всего у `msd_radix_sort`, тогда как больше всего `quick_sort`.
4. `comparisons_reverse.png` - изображение соответствует количеству посимвольных сравнений у обратно отсортированных массивов строк. Больше всего у `quick_sort`, потом идёт `string_quick_sort` и `string_merge_sort` (у него одинаково с обычным `merge`). Меньше всего у `msd_radix_sort`.



Время выполнения: 

1. `time_almost.png` - изображение соответствует времени сортировки почти отсортированных массивов. Дольше всего сортировал обычный `merge_sort`. Затем идёт `string_quick_sort`. Потом идёт `string_merge_sort` (заметен выигрыш у обычного). Затем идёт `msd_radix_sort`. И за самое быстрое выполнения конкурируют `quick_sort` и обычный `msd_radix_sort_switch`.
2. `time_prefix.png` - изображение соответствует времени сортировки массивов с совпадающими префиксами. Тут уже поинтереснее. Дольше всего работали `msd_radix_sort_switch` и `msd_radix_sort`. Близко к ним и обычный `merge_sort`. Быстрее них работает `string_merge_sort`. Близко к нему, почти на равных обычный `quick_sort`. И самым быстрым оказался `string_quick_sort`.
3. `time_random.png` - изображение соответствует времени сортировки рандомных массивов строк. Дольше всего работал `merge_sort`. После него шёл `string_quick_sort`. Затем шёл `string_merge_sort`. Самым быстрым оказался `msd_radix_sort`.
4. `time_reverse.png`- изображение соответствует времени сортировки обратно отсортированных массивов строк. Самым медленным вновь оказался обычный `merge_sort`. Ну и далее ситуация оказалась практически аналогичной.



Анализ результатов:

1. `msd_radix_sort` - показывает наименьшее количество посимвольных сравнений на всех типах данных. Преимущество этого алгоритма объясняется тем, что:

- Он не выполняет прямых сравнений всей строки целиком
- Классификация строк происходит по одному символу за раз
- Сравнение выполняется только для определения корзины (bucket), в которую помещается строка


При обработке длинных строк с небольшим количеством различающихся символов (особенно в начале строк) этот подход дает значительное преимущество. Именно поэтому MSD Radix Sort демонстрирует лучшую производительность на случайных и обратно отсортированных массивах.

Однако для массивов с общим префиксом MSD Radix Sort показывает не самое лучшее время выполнения, несмотря на малое количество сравнений. Это объясняется накладными расходами на создание и обработку корзин для каждого символа префикса, которые в этом случае могут быть значительными.



2. `string_quick_sort` - показывает интересные результаты. На данных с общим префиксом этот алгоритм демонстрирует лучшее время выполнения среди всех алгоритмов. Алгоритм эффективен, когда строки имеют общие префиксы, так как:

- Разбиение выполняется по одному символу, а не по всей строке
- Рекурсивный вызов для части строк с одинаковым символом увеличивает позицию сравниваемого символа
- Трехпутевое разделение позволяет эффективно обрабатывать случаи с повторяющимися символами


3. `string_merge_sort` - где `lcp`. По времени выполнения String MergeSort показывает лучшие результаты по сравнению с обычным MergeSort. Это подтверждает утвердение из условия об учёте префиксов строк.


4. `msd_radix_sort_switch` - гибридный алгоритм `MSD Radix Sort` с переключением на `QuickSort` показывает хорошие результаты, особенно на почти отсортированных массивах. Он сочетает преимущества обоих алгоритмов:
- Эффективность Radix Sort для больших подмассивов
- Эффективность QuickSort для малых подмассивов (меньше размера алфавита)


5. Стандартные `merge_sort` и `quick_sort` оказались медленнее своих более оптимизированных под работу со строками собратьев для массивов строк с совпадающими префиксами. Подтверждение гипотезы из условия.



Итоги выполнения:

1. Выбор алгоритмов зависит от характеристик обрабатываемых строк. Где-то лучше одни, где-то другие.
2. Количество символьных сравнений - не единственный фактор производительности. Не всегда это коррелировало со временем выполнения.
3. Специализированные алгоритмы давали ряд преимуществ в определённых ситуациях Ярко это проявилось в сравнении тернарного `quick_sort` с обычным и `string_merge_sort` с обычным для массивов с общими префиксами. Подтвердилось утверждение из условия.
4. Гибридный подход оказался довольно эффективным для реальных данных. Различия в `msd_radix_sort` и `msd_radix_sort_switch` это иллюстрируют.
5. Теоретические оценки сложности алгоритмов в качестве предположений о скорости их работы в целом подтверждаются данными.



